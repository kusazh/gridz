<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>中文排版测试</title>
    <style>
      @font-face {
        src: url(https://ethantw.github.io/Han/latest/font/han-space.woff?v3.3.0)
            format("woff"),
          url(https://ethantw.github.io/Han/latest/font/han-space.otf?v3.3.0)
            format("opentype");
        font-family: "Han Space";
        unicode-range: U + 20;
      }

      body {
        font-family: sans-serif;
        width: 25em;
        margin: 0 auto;
        padding: 2em;
        line-height: 2;
        hanging-punctuation: allow-end;
        -webkit-font-smoothing: antialiased;

        background-image: linear-gradient(
            to right,
            lightgrey 1px,
            transparent 1px
          ),
          linear-gradient(to bottom, lightgrey 1px, transparent 1px);
        background-size: 1em 1em;
        background-position: center center;
      }

      @media screen and (max-width: 40em) {
        body {
          width: 15em;
        }
      }

      body,
      body * {
        font-size: 24px;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      p {
        margin: 0 -0.5em 0 0;
        padding: 1em 0 1em 0;
      }

      .ans {
        display: inline-block;
        text-align: center;
      }

      .bds-container {
        position: relative;
        margin-inline-end: 0.035em;
      }

      .bds-container:before {
        content: "\0020";
        display: inline;
        font: 1em "Han Space";
      }

      /* .bds {
        display: inline-flex;
      } */

      /* .bds > span {
        flex: 1;
        text-align: center;
        overflow: hidden;
      } */

      .bds > span {
        display: inline-block;
        position: absolute;
        left: 0;
        top: -0.25em;
      }
    </style>
  </head>

  <body>
    <article>
      <h1>字母汤</h1>
      <p>
        字母汤的本质是缩略语的滥用。缩略语随着语言的发展而发展，一个缩略语可能包含另一个缩略语。以中文为例，「喜闻乐见、大快人心、普天同庆、奔走相告」四个词本身已经是成语——某种缩略语。而这四个成语又组合成新的缩略语「喜大普奔」。以此推导，未来又将产生由「喜大普奔」组成的新缩略语。
      </p>
      <p>
        令「喜大普奔、闻鸡起舞、乐善好施、见利忘义」四个词组成新的缩略语「喜闻乐见」，就产生了一种回环：喜闻乐见—喜大普奔—喜闻乐见。一个时代产生越多文本资讯，那么这个时代就越有可能发生这样的字母汤问题。这正是我在这个人工智慧世代的担忧，即文中所指：「人工智慧后带来的语言问题太多了，用不了。」
      </p>
      <p>字母汤问题愈发严重，会带来几个问题：</p>
      <p>
        字母越少的语言越先消亡。考虑到英文只有二十六个字母而汉字有数千种，在这样的一种未来下人们就只能改用中文了。
      </p>
      <p>
        表达能力的下降。因为大量缩略语的存在，会造成大量的双关、谐音问题，使日常表达受损。我的假想是未来人们甚至很难起名，于是在文中介绍了「名图（namegraph）」这种概念，即人们将通过一张图片来identify个体。
      </p>
      <p>
        进而我将热力学概念「熵爆（entropic
        explosion）」引入到资讯理论中，借用资讯熵创造了「语言熵爆（entropic
        explosion of language,
        EEL）」。用来指代当一个人的语言系统过于混乱后造成的失能状态。
      </p>
      <p>
        我构思用反乌托邦的方式解决上述问题，即成立政府部门找出语言中较不存在字母汤问题的词汇，以二十世纪为蓝本，自上而下地重塑语言。至此，语言不再民主，只能由独裁的方式产生。
      </p>
    </article>
    <script>
      // 部分正则表达式修改自 pangu.js https://github.com/vinta/pangu.js
      const CJK =
        "\u2e80-\u2eff\u2f00-\u2fdf\u3040-\u309f\u30a0-\u30fa\u30fc-\u30ff\u3100-\u312f\u3200-\u32ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff";
      const A = "A-Za-z\u0080-\u00ff\u0370-\u03ff";
      const N = "0-9";
      const S = "`~!@#\\$%\\^&\\*\\(\\)-_=\\+\\[\\]{}\\\\\\|;:'\",<.>\\/\\?";
      const ANS = `${A}${N}${S}`;
      const REG_CJK_FULL = `(?<=[${CJK}])( *[${ANS}]+(?: +[${ANS}]+)* *)(?=[${CJK}])`;
      const REG_CJK_START = `([${ANS}]+(?: +[${ANS}]+)* *)(?=[${CJK}])`;
      const REG_CJK_END = `(?<=[${CJK}])( *[${ANS}]+(?: +[${ANS}]+)*)`;
      const REG_CJK_FULL_WITHOUT_LOOKBEHIND = `(?:[${CJK}])( *[${ANS}]+(?: +[${ANS}]+)* *)(?=[${CJK}])`;
      const REG_CJK_END_WITHOUT_LOOKBEHIND = `(?:[${CJK}])( *[${ANS}]+(?: +[${ANS}]+)*)`;
      const REG_BD_STOP = `。．，、：；！‼？⁇`;
      const REG_BD_SEP = `·・‧`;
      const REG_BD_OPEN = `「『（《〈【〖〔［｛`;
      const REG_BD_CLOSE = `」』）》〉】〗〕］｝`;
      const REG_BD_START = `${REG_BD_OPEN}${REG_BD_CLOSE}`;
      const REG_BD_END = `${REG_BD_STOP}${REG_BD_OPEN}${REG_BD_CLOSE}`;
      const REG_BD_HALF_OPEN = `“‘`;
      const REG_BD_HALF_CLOSE = `”’`;
      const REG_BD_HALF_START = `${REG_BD_HALF_OPEN}${REG_BD_HALF_CLOSE}`;

      document.querySelectorAll("p").forEach((p) => {
        let ansOpened = false;
        let bdsOpened = false;
        const chars = [];

        [...p.textContent.trim()].forEach((char) => {
          if (new RegExp(`[${ANS}]`).test(char)) {
            if (!ansOpened) {
              if (bdsOpened) {
                chars.push("</span></span>");
                bdsOpened = false;
              }
              chars.push('<span lang="en" class="ans">');
              ansOpened = true;
            }
          } else {
            if (ansOpened) {
              chars.push("</span>");
              ansOpened = false;
            }
          }

          if (new RegExp(`[${REG_BD_END}]`).test(char)) {
            if (!bdsOpened) {
              if (ansOpened) {
                chars.push("</span>");
                ansOpened = false;
              }
              chars.push('<span class="bds-container"><span class="bds">');
              bdsOpened = true;
            }
          } else {
            if (bdsOpened) {
              chars.push("</span></span>");
              bdsOpened = false;
            }
          }

          if (ansOpened || bdsOpened) {
            chars.push(`<span>${char}</span>`);
          } else if (!/\s+/g.test(char)) {
            chars.push(char);
          }
        });

        if (ansOpened) {
          chars.push("</span>");
        }

        if (bdsOpened) {
          chars.push("</span></span>");
        }

        p.innerHTML = chars.join("");
      });

      document.querySelectorAll("span.ans").forEach((span) => {
        const rect = span.getBoundingClientRect();
        const emPx = parseFloat(getComputedStyle(span).fontSize);
        const widthInEm = rect.width / emPx;
        const targetMultiple = Math.ceil(widthInEm + 0.2);

        if (targetMultiple > 0) {
          span.style.width = `${targetMultiple}em`;
        }
      });

      document.querySelectorAll("span.bds").forEach((span) => {
        const l = span.querySelectorAll("span").length;
        span.parentElement.dataset.contentLength = "\u00A0".repeat(
          Math.ceil(l / 2)
        );

        span.querySelectorAll("span").forEach((s, i) => {
          if (i > 0) {
            if (new RegExp(`[${REG_BD_OPEN}]`).test(s.textContent)) {
              s.style.left = `${0.5 * (i - 1)}em`;
            } else {
              s.style.left = `${0.5 * i}em`;
            }
          }
          if (i > 1) {
            s.parentElement.style.marginInlineEnd = `${i - 1}em`;
          }
        });
      });
    </script>
  </body>
</html>
